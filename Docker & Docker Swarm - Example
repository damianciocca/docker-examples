
Docker - Tutorial Completo

=======> CONTAINER:
https://docs.docker.com/get-started/part2/#apppy

	1. creamos una app web en python y la dockerizamos con Dockerfile
		
		# Use an official Python runtime as a parent image
		FROM python:2.7-slim

		# Set the working directory to /app
		WORKDIR /app

		# Copy the current directory contents into the container at /app
		ADD . /app

		# Install any needed packages specified in requirements.txt
		RUN pip install --trusted-host pypi.python.org -r requirements.txt

		# Make port 80 available to the world outside this container
		EXPOSE 80

		# Define environment variable
		ENV NAME World

		# Run app.py when the container launches
		CMD ["python", "app.py"]

	2. buildeamos la imagen 
		docker build -t friendlyhello .

	3. verificamos la imagen creada
		docker image ls	

	4. levantamos la imagen en un container => mapping your machine’s port 4000 to the container’s published port 80 using -p
		4.1. docker run -p 4000:80 friendlyhello	

			curl http://localhost:4000

		o bien levantamos en background

		4.2. docker run -d -p 4000:80 friendlyhello 

	5. verificamos los containers corriendo

		docker containers ls

	6. paramos el container
		
		docker container stop <CONTAINER_ID>

	7. subimos la imagen a docker registry para compartirla
	
		7.1 sacamos una cta en docker hub
			Docker Propio (dockerhub)	
				https://hub.docker.com/r/damianciocca/examples/
				ID damianciocca	
				pass racing90	

		7.2 nos logueamos a docker hub		

			docker login

			Nota: The notation for associating a local image with a repository on a registry is username/repository:tag. The tag is optional, but recommended, since it is the mechanism that registries use to give Docker images a version

			Creamos un repository con el nombre "examples"

		7.2 tagueamos la imagen creada 
			Ej: docker tag image username/repository:tag
			
			Verificamos q la imagen este creada con el nombre friendlyhello
			docker images
				REPOSITORY             TAG                 IMAGE ID            CREATED             SIZE
				friendlyhello          latest              265482889e93        20 minutes ago      132MB

			docker tag friendlyhello damianciocca/examples:part2	

			docker images
				REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE
				damianciocca/examples   part2               265482889e93        24 minutes ago      132MB

		7.3 publicamos la imagen a docker hub

			docker push damianciocca/examples:part2

		7.3 pull & run 
		
			docker run -p 4000:80 damianciocca/examples:part2	

=======> SERVICES (en un nodo):
https://docs.docker.com/get-started/part3/#prerequisites

	Nota: Services are really just “containers in production.” A service only runs one image,

		1. Creamos un stack de servicios: stack.yml (esto es el docker-compose)
			version: "3"
				services:
				  web:
				    # replace username/repo:tag with your name and image details
				    image: damianciocca/examples:part2
				    deploy:
				      replicas: 5
				      resources:
				        limits:
				          cpus: "0.1"
				          memory: 50M
				      restart_policy:
				        condition: on-failure
				    ports:
				      - "80:80"
				    networks:
				      - webnet
				networks:
				  webnet:

			This docker-compose.yml file tells Docker to do the following:

			Pull the image we uploaded in step 2 from the registry.

			Run 5 instances of that image as a service called web, limiting each one to use, at most, 10% of the CPU (across all cores), and 50MB of RAM.

			Immediately restart containers if one fails.

			Map port 80 on the host to web’s port 80.

			Instruct web’s containers to share port 80 via a load-balanced network called webnet. (Internally, the containers themselves publish to web’s port 80 at an ephemeral port.)

			Define the webnet network with the default settings (which is a load-balanced overlay network).

			Importante: Es ver que estas 5 replicas tienen un load balancer interno q distribuye los pedidos aca cada replica

	  	2. Inicializamos docker swarm para poder deployar el docker compose previo (stack.yml)
			
			docker swarm init	

		3. deployamos el stack de servicios (docker compose) en el docker swarm inicializado previamente
		
			docker stack deploy -c stack.yml getstartedlab	

				* Creating network getstartedlab_webnet
				* Creating service getstartedlab_web

				Our single service stack is running 5 container instances of our deployed image on one host

		4. verificamos el stack deployado

			docker stack ls

				NAME                SERVICES
				getstartedlab       1

		4. verificamos los servicios activos de los stacks
		
			docker service ls 

			ID                  NAME                MODE                REPLICAS            IMAGE                         PORTS
			eg8a79wg1gfu        getstartedlab_web   replicated          5/5                 damianciocca/examples:part2   *:80->80/tcp
	
		5. verificamos los logs

			docker service logs getstartedlab_web --follow	

		6. verificamos los procesos/tareas/tasks de un servicio
		
			docker service ps getstartedlab_web	

			ID                  NAME                  IMAGE                         NODE                DESIRED STATE       CURRENT STATE ix9pnwp6lu71        getstartedlab_web.1   damianciocca/examples:part2   moby                Running             Running 6 minutes ago
			4m75crg2cn87        getstartedlab_web.2   damianciocca/examples:part2   moby                Running             Running 6 minutes ago
			qsbyoe7gyg04        getstartedlab_web.3   damianciocca/examples:part2   moby                Running             Running 6 minutes ago
			w1wb0c5ilruy        getstartedlab_web.4   damianciocca/examples:part2   moby                Running             Running 6 minutes ago
			hmllw5tib91n        getstartedlab_web.5   damianciocca/examples:part2   moby                Running             Running 6 minutes ago

		7. 	Verificamos que cada pedido q hagamos una de las replicas va a responder

			Either way, the container ID changes, demonstrating the load-balancing; with each request, one of the 5 tasks is chosen, in a round-robin fashion, to respond. The container IDs match your output from the previous command (docker container ls -q).

		8.  Agregamos mas replicas	

			You can scale the app by changing the replicas value in stack.yml, saving the change, and re-running the docker stack deploy command:

				docker stack deploy -c stack.yml getstartedlab

		9. removemos el stack (swarm) y por ende, se bajaran los servicios (en este caso dos) y de cada servicio de eliminarn los procesos/tasks (en este caso 5 replicas)

				docker stack rm getstartedlab

					Removing service getstartedlab_web
					Removing network getstartedlab_webnet		

				o bien
				
				docker swarm leave --force

					Node left the swarm.

=======> CLUSTER (servicios en varios nodos - diferentes machines)
https://docs.docker.com/get-started/part4/							
				

